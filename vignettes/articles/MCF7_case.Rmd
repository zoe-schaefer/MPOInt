---
title: "MCF7 case"
bibliography: "references.bib"
---
This pipeline is intended for use with three levels of proteomics data: total proteome, phosphoproteome, and histone proteome. Total and phosphoproteome data are sourced from @Han2024. Total and phosphoproteome data are designed to be input as an Excel sheet from MaxQuant, and the histone data are derived from @LeRoy2013.

For the reader, code chunks are collapsible in-text. The full R Markdown source document can also be downloaded from this page by clicking the “Code” dropdown above. Additionally, we have made available the files generated from our data at the project repository on Github. Other files can be downloaded from their respective sources.

```{r knit, include = FALSE}
library(knitr)
library(rmarkdown)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
if (!requireNamespace('BiocManager', quietly = TRUE)) {
    install.packages('BiocManager')
}
library('BiocManager')

library(MPOInt)
# Install from CRAN if necessary
CRAN_pkgs <- c("stringr", "tibble", "ggvenn", "devtools",
               "reticulate", "igraph", "tidyr", "BiocManager",
               "ggrepel", "scales", "paletteer", "htmltools", "dplyr")
package.check <- sapply(
  CRAN_pkgs,
  FUN = function(x) {
    if (!requireNamespace(x, quietly = TRUE)) {
      install.packages(x, dependencies = TRUE)
      }
    library(x, character.only = TRUE)
  }
)

# Install from Bioconductor if necessary
Bioc_pkgs <- c("clusterProfiler", "enrichplot",
               "OrganismDbi", "Homo.sapiens", "msigdbr")
package.check <- sapply(
  Bioc_pkgs,
  FUN = function(x) {
    if (!requireNamespace(x, quietly = TRUE)) {
      BiocManager::install(x, dependencies = TRUE)
      }
    library(x, character.only = TRUE)
  }
)

# Install from GitLab if necessary
if (!requireNamespace("disgenet2r", quietly = TRUE)) {
  tryCatch(
    {
      install_gitlab("medbio/disgenet2r", quiet = TRUE)
    },
    error = function(e) {
      warning("Failed to install 'disgenet2r' from GitLab: ", conditionMessage(e))
    }
  )
}
if (requireNamespace("disgenet2r", quietly = TRUE)) {
  library(disgenet2r)
} else {
  warning("'disgenet2r' package is not available. Some functionality may be limited.")
}

library(MPOInt)
remove(Bioc_pkgs, CRAN_pkgs, package.check)
```

Most variables that need to be adjusted for individual datasets should be set here.

```{r set-vars}
total_p_threshold <- 0.05
total_FC_threshold <- 0.5
phospho_p_threshold <- 0.05
phospho_FC_threshold <- 0.5
histone_p_threshold <- 0.05
histone_FC_threshold <- 0.5
```

If you have not previously set up the `disgenet2r` package, run this chunk with your API key.

```{r d2r-setup, eval = FALSE}
#DISGENET_API_KEY <- "#####"
# Below line is for example purposes - make sure to use your own API key above and comment the next line out or delete it
get_api_key <- Sys.getenv("api_key")
 
# Keep the next line to create an environment variable with the correct API key
Sys.setenv(DISGENET_API_KEY = get_api_key)
```

If you have not previously set up a Python environment from RStudio, run this chunk.

```{r python-1st-setup}
virtualenv_create("r-reticulate")
use_virtualenv("r-reticulate")
virtualenv_install("r-reticulate", c("pandas", "networkx", "pyvis"), action = "add")
```

# 1. Proteome data processing
This section prepares proteome data. For data other than the example, read in the data in place of the `data()` call.

```{r total-processing}
data(MCF7_total)
# Renaming to reader-friendly names not necessary here
# Mapping ENTREZ and UNIPROT IDs already done
# Dropping anything with an undefined or duplicate symbol
MCF7_total <- MCF7_total %>%
  tidyr::drop_na(SYMBOL2) %>%
  dplyr::distinct(SYMBOL2, .keep_all = TRUE)
# Assigning row names already done

# Creating a separate set of significant points for later analysis
MCF7_total_sig <- dplyr::filter(MCF7_total, `P value` < total_p_threshold)
```

## 1.1. Volcano plots
Here we create several volcano plots to show the data.

```{r total-opts}
# Setting this value - geom_text_repel will only show so many labels at once
# for legibility reasons. Adjust this threshold to show more/fewer points.
options("ggrepel.max.overlaps" = 20)

volcanoplot(df = MCF7_total, fc_col = "log2(FC)",
            p_col = "P value", label_col = "SYMBOL2") +
  ggtitle("Volcano plot") + xlab("log2(FC)") + ylab("-log10(P-value)")
```

If you have known proteins of interest, use `volcano_groups()` to highlight them on a graph.

```{r total-groups}
# For known groups of interest
volcano_groups(df = MCF7_total, fc_col = "log2(FC)", p_col = "P value", label_col = "SYMBOL2",
  group_list = list("Group 1" = c("TP53", "KMT2C", "NCOR1", "ARID1A", "SPEN", "FOXA1", "KMT2D", "KMT2A", "ATRX", "UBR5", "BRCA2", "RB1", "CHD4", "ATM", "SETD2", "CTCF"), "Group 2" = c("PIK3CA", "CDH1", "GATA3", "MUC16", "MAP3K1", "PTEN", "MAP2K4", "FAT3", "CSMD3", "NF1", "RUNX1", "TBX3", "FAT1", "AKAP9", "LRP1B", "MYH9", "BIRC6", "CBFB", "AKT1", "PIK3R1", "PTPRD", "ERBB2", "PREX2", "FAT4", "MUC4", "MED12", "RNF213", "NOTCH2", "FLNA", "ZFHX3", "ERBB3", "MTOR", "ANK1", "PTPRB"))) +
  scale_color_manual(values = c("Group 1" = "red", "Group 2" = "blue", "None" = "gray")) +
  ggtitle("Grouped volcano plot") + xlab("log2FC") + ylab("-log10P")
```

## 1.2. GSEA
This section prepares and performs a GSEA analysis on the total proteome data.

```{r total-GSEA-list}
# Need a named list in decreasing order
total_GSEA_list <- MCF7_total$`log2(FC)`
names(total_GSEA_list) <- MCF7_total$ENTREZID
total_GSEA_list <- na.omit(total_GSEA_list)
total_GSEA_list <- sort(total_GSEA_list, decreasing = TRUE)
```

```{r total-enrich}
total_GSEA_GO <- gseGO(geneList = total_GSEA_list, OrgDb = "org.Hs.eg.db",
                    verbose = FALSE, ont = "ALL")
# By visual inspection, this contains overlapping terms
simple_total_GSEA_GO <- clusterProfiler::simplify(total_GSEA_GO)
total_GSEA_KEGG <- gseKEGG(geneList = total_GSEA_list, verbose = FALSE)
```

Plotting GSEA dot plots can be difficult due to the volume of information included. Changing the value of `label_format` adjusts the label wrapping, which can help crowded figures.

```{r total-enrich-plots, fig.dpi = 300}
if (nrow(total_GSEA_GO@result) > 0) {
  dotplot(total_GSEA_GO, showCategory = 20, font.size = rel(1), label_format = 40, title = "GO enrichment",
          split = "ONTOLOGY") + facet_wrap(ONTOLOGY~.sign, scales = "free_y", ncol = 2)
} else {
  print("Error: no terms enriched under P-value cutoff (total_GSEA_GO)")
}

if (nrow(simple_total_GSEA_GO@result) > 0) {
  dotplot(simple_total_GSEA_GO, showCategory = 20, font.size = rel(1), label_format = 40, title = "Simplified GO enrichment",
          split = "ONTOLOGY") + facet_wrap(ONTOLOGY~.sign, scales = "free_y", ncol = 2)
} else {
  print("Error: no terms enriched under P-value cutoff (simple_total_GSEA_GO)")
}

if (nrow(total_GSEA_KEGG@result) > 0) {
  dotplot(total_GSEA_KEGG, showCategory = 20, font.size = rel(1), label_format = 40, title = "KEGG enrichment",
          split = ".sign") + facet_wrap(.~.sign)
} else {
  print("Error: no terms enriched under P-value cutoff (total_GSEA_KEGG)")
}
```
```{r clear-1}
# Clearing large variables
rm(MCF7_total, total_GSEA_GO, simple_total_GSEA_GO, total_GSEA_KEGG, total_GSEA_list)
```



# 2. Phosphoproteome data processing
Similar to the previous section, this prepares phosphoproteome data.

```{r phosphoproteome-processing}
# Renaming to reader-friendly names not necessary here
data(MCF7_phospho)
# Mapping ENTREZ IDs and a gene symbol column to UniProt IDs for later analysis
MCF7_phospho <- dplyr::left_join(MCF7_phospho, OrganismDbi::select(
  Homo.sapiens::Homo.sapiens,
  keys = OrganismDbi::keys(Homo.sapiens::Homo.sapiens, keytype = "ENTREZID"),
  columns = c("UNIPROT", "SYMBOL"), keytype = "ENTREZID"
), by = dplyr::join_by(SYMBOL2 == SYMBOL, ENTREZID), keep = FALSE, relationship = "many-to-many")
# Dropping anything with an undefined or duplicate symbol
MCF7_phospho <- MCF7_phospho %>%
  tidyr::drop_na(SYMBOL2) %>%
  dplyr::distinct(SYMBOL2, .keep_all = TRUE)
# Assigning row names
MCF7_phospho <- MCF7_phospho %>%
  dplyr::mutate("SYMBOL" = `SYMBOL2`) %>%
  tibble::column_to_rownames(var = "SYMBOL")

# Creating a separate set of significant points for later analysis
MCF7_phospho_sig <- dplyr::filter(MCF7_phospho, `P value` < phospho_p_threshold)
```

## 2.1. Volcano plots
```{r phospho-plot}
# Setting this value - geom_text_repel will only show so many labels at once
# for legibility reasons. Adjust this threshold to show more/fewer points.
options("ggrepel.max.overlaps" = 20)

volcanoplot(df = MCF7_phospho, fc_col = "log2(FC)",
            p_col = "P value", label_col = "SYMBOL2") +
  ggtitle("Volcano plot") + xlab("log2(FC)") + ylab("-log10(P-value)")
```

```{r phospho-groups}
# For known groups of interest
volcano_groups(df = MCF7_phospho, fc_col = "log2(FC)", p_col = "P value", label_col = "SYMBOL2",
  group_list = list("Group 1" = c("ASH2L", "ASXL1", "ASXL2", "BAP1", "BMI1", "CHD4", "EZH2", "DMAP1",
  "EP400", "GATAD2B", "KANSL1", "KANSL3", "KMT2C", "KMT2D", "MBD3",
  "MEN1", "MGA", "MRGBP", "MTA1", "NCOA6", "PHC2", "PHF20L1", "REST",
  "RING1", "RUVBL1", "SAP130", "SCML2", "SIRT3", "SIRT6", "EP300"), "Group 2" = c("FANCI", "CDK14", "PRDM1", "ICAM1", "CDK1", "RUNX3", "NOTCH3", "CASP8",
  "BST2", "CTSL", "MX2", "CASP1", "STAT2", "MX1"))) +
  scale_color_manual(values = c("Group 1" = "red", "Group 2" = "blue", "None" = "gray")) +
  ggtitle("Grouped volcano plot") + xlab("log2FC") + ylab("-log10P")
```

## 2.2. GSEA
```{r phospho-GSEA-list}
# Need a named list in decreasing order
MCF7_phospho <- drop_na(MCF7_phospho, ENTREZID) %>% distinct(ENTREZID, .keep_all = TRUE)
phospho_GSEA_list <- MCF7_phospho$`log2(FC)`
names(phospho_GSEA_list) <- MCF7_phospho$ENTREZID
phospho_GSEA_list <- sort(phospho_GSEA_list, decreasing = TRUE)
```

```{r phospho-enrich}
phospho_GSEA_GO <- gseGO(geneList = phospho_GSEA_list, OrgDb = "org.Hs.eg.db",
                    verbose = FALSE, ont = "ALL")
phospho_GSEA_KEGG <- gseKEGG(geneList = phospho_GSEA_list, verbose = FALSE)
```

```{r phospho-enrich-plots}
if (nrow(phospho_GSEA_GO@result) > 0) {
  dotplot(phospho_GSEA_GO, showCategory = 20, font.size = rel(1), label_format = 50, title = "GO enrichment",
          split = "ONTOLOGY") + facet_wrap(ONTOLOGY~.sign, scales = "free_y", ncol = 2)
} else {
  print("Error: no terms enriched under P-value cutoff (simple_phospho_GSEA_GO)")
}

if (nrow(phospho_GSEA_KEGG@result) > 0) {
  dotplot(phospho_GSEA_KEGG, showCategory = 20, font.size = rel(1), label_format = 40, title = "KEGG enrichment",
          split = ".sign") + facet_wrap(.~.sign, scales = "free", ncol = 2)
} else {
  print("Error: no terms enriched under P-value cutoff (phospho_GSEA_KEGG)")
}
```

```{r clear-2}
# Clearing large variables
rm(phospho_GSEA_GO, phospho_GSEA_KEGG, MCF7_phospho,
   phospho_GSEA_list)
```

# 3. Histone processing
This section processes EpiProfile output into a more readable, user-friendly format. In this case, the epiproteome data is in a summary statistics format, where each condition is only presented as a mean value with standard deviation. We create a standard baseline and then generate a P value from a T score.

```{r histone-import-mean}
data(MCF7_histones)
histone_frag_raw <- MCF7_histones
# Creating an overall baseline by averaging the non-cancer cell lines
histone_frag_raw<- histone_frag_raw %>% mutate("avg std" = apply(pick("293 ave (5 reps)", "HaCAT ave (5 reps)",
                                    "hESC ave (6 reps)", "HFF ave (7 reps)",
                                    "Mdm13 ave (5 reps)"), 1, sd))
histone_frag_raw <- histone_frag_raw %>% 
  dplyr::select(c("PTM", "MCF7 ave (5 reps)", "MCF7 std", "ctrl ave", "avg std")) %>% 
  mutate("log2(FC)" = log2(`MCF7 ave (5 reps)`/`ctrl ave`)) %>% 
  mutate("T score" = NA) %>% 
  mutate("P value" = NA)
histone_frag <- histone_frag_raw
histone_frag <- histone_frag %>%
  mutate("T score" = (`MCF7 ave (5 reps)` - `ctrl ave`)/(`MCF7 std`/sqrt(5))) %>% 
  mutate("P value" = pt(q = `T score`, df = 4))
```

## 3.1. Individual values
### 3.1.1. Fragments
The data available here was already in a legible format, so we do not have to process it extensively.

```{r fragment-plot}
# Setting this value - geom_text_repel will only show so many labels at once
# for legibility reasons. Adjust this threshold to show more/fewer points.
options("ggrepel.max.overlaps" = 20)

volcano_epi(df = histone_frag, fc_col = "log2(FC)",
            p_col = "P value", label_col = "PTM") +
  labs(title = "Volcano plot", x = "log2(FC)", y = "-log10(P-value)")
```

### 3.1.2. Single
This section parses the fragments into single PTMs. Each occurrence is counted individually - for example, H4 4-17 K5acK12acK16ac would be counted as H4K5ac, H4K8ac, and H4K16ac.

```{r single-processing, warning = FALSE}
# warnings silenced - multiple warnings come up if a regex string is empty
histone_single_raw <- histone_frag_raw
histone_single_raw <- histone_single_raw[!grepl("\\.", histone_single_raw$PTM),]
histone_single_unmod <- histone_single_raw[grepl("unmod", histone_single_raw$PTM),]
histone_single_raw <- histone_single_raw[!grepl("unmod", histone_single_raw$PTM),]

histone_single_raw <- histone_single_raw %>% 
  mutate("subset" = str_extract(`PTM`, "([^\ ]+$)")) %>% 
  mutate("PTM4" = str_split_i(`subset`, "(?=K)", i = -1)) %>% 
  mutate("PTM3" = str_split_i(`subset`, "(?=K)", i = -2)) %>% 
  mutate("PTM2" = str_split_i(`subset`, "(?=K)", i = -3)) %>% 
  # add line above for max co-occurring PTMs, then remove
  mutate("PTM1" = str_remove(`subset`, `PTM2`)) %>% 
  mutate("PTM1" = str_remove(`PTM1`, `PTM3`)) %>% 
  mutate("PTM1" = str_remove(`PTM1`, `PTM4`))

histone_single_raw <- replace(histone_single_raw, histone_single_raw == "", NA)

histone_single_long <- histone_single_raw %>% 
  pivot_longer(cols = c("PTM4", "PTM3", "PTM2", "PTM1"), names_to = NULL,
               values_to = "single_PTM", values_drop_na = TRUE) %>% 
  mutate("PTM" = str_remove(`PTM`, `subset`)) %>% 
  unite(col = "PTM", c(`PTM`, `single_PTM`), sep = " ", remove = TRUE) %>% 
  mutate("PTM" = str_squish(PTM))

histone_single_long$PTM <- str_remove(histone_single_long$PTM, " .+ ") %>% 
  str_replace("me1", "me")
histone_single_long <- bind_rows(histone_single_long, histone_single_unmod)
```

```{r single-stats-t}
histone_single_raw <- histone_single_long %>% 
  group_by(`PTM`) %>% 
  summarize("sample ave" = mean(`MCF7 ave (5 reps)`),
            "sample std" = mean(`MCF7 std`),
            "ctrl ave" = mean(`ctrl ave`),
            "avg std" = mean(`avg std`),
            "T score" = "",
            "P value" = "") %>% 
  mutate("log2(FC)" = log2(`sample ave`/`ctrl ave`))

histone_single_p <- histone_single_raw %>% 
  mutate("T score" = (`sample ave` - `ctrl ave`)/(`sample std`/sqrt(5))) %>% 
  mutate("P value" = pt(q = `T score`, df = 4))

histone_single_p$PTM <- str_remove(histone_single_p$PTM, " .+ ") %>% 
  str_remove("un") %>% 
  str_replace("me1", "me")
```
```{r clear-3}
# Clearing large variables
rm(MCF7_histones, histone_frag, histone_frag_raw, histone_p,
   histone_single_long, histone_single_long_p, histone_single_raw,
   histone_single_unmod, single_p)
```

# 3.5 test
```{r}
GDA_ERBC <- msigdbr(collection = "C2") %>% filter(gs_id == "M18299")
GDA_HT <- msigdbr(collection = "C5") %>% filter(gs_exact_source == "HP:0000822")
GDA_OvCa <- msigdbr(collection = "C5") %>% filter(gs_exact_source == "HP:0100615")
```

# 4. Disease enrichment
Here we perform disease enrichment using the DisGeNET database. We first search for a list of Concept Unique Identifiers (CUIs) that identify a specific disease of interest. If a CUI is already known, that can be used in the following chunks.

```{r GDA-CUI-fetch, eval = FALSE}
GDA_table_BC <- get_umls_from_vocabulary(disease = "breast cancer",  vocabulary = "NAME" ,  limit = 10)@qresult
knitr::kable(GDA_table_BC, caption = "List of CUIs that map to breast cancer", row.names = F)  
```

We enrich our primary disease of interest (breast cancer), but also include enrichment for hypertension and ovarian cancer.

```{r GDA-setup, eval = FALSE}
GDA_ERBC <- disease2gene(disease = "UMLS_C0678222", database = "CURATED")@qresult
GDA_HT <- disease2gene(disease = "UMLS_C2973725", database = "CURATED")@qresult
GDA_OvCa <- disease2gene(disease = "UMLS_C0677886", database = "CURATED")@qresult
```

This chunk creates Venn diagrams of the overlap between proteins that were significant and above the fold change threshold in the total and phosphoproteome, as well as the genes of interest that were just retrieved.

```{r GDA, fig.asp = 1}
# Get lists of proteins that were significant AND above the FC threshold
total_FC <- filter(MCF7_total_sig, abs(`log2(FC)`) > total_FC_threshold)
phospho_FC <- filter(MCF7_phospho_sig, abs(`log2(FC)`) > phospho_FC_threshold)

# Generate plot
ggvenn(list(
  "ER breast cancer" = GDA_ERBC$gene_symbol,
  "Total proteome" = total_FC$SYMBOL2,
  "Phosphoproteome" = phospho_FC$SYMBOL2),
  fill_color = c("#440154", "#21908C", "#FDE725"),
  show_percentage = FALSE, text_size = 5) + ggtitle("MCF-7 enrichment") + theme(
  plot.title.position = "plot",
  plot.title = element_text(hjust = 0.5))

ggvenn(list(
  "Hypertension" = GDA_HT$gene_symbol,
  "Total proteome" = total_FC$SYMBOL2,
  "Phosphoproteome" = phospho_FC$SYMBOL2),
  fill_color = c("#440154", "#21908C", "#FDE725"),
  show_percentage = FALSE, text_size = 5) + ggtitle("MCF-7 enrichment") + theme(
  plot.title.position = "plot",
  plot.title = element_text(hjust = 0.5))

ggvenn(list(
  "Ovarian cancer" = GDA_OvCa$gene_symbol,
  "Total proteome" = total_FC$SYMBOL2,
  "Phosphoproteome" = phospho_FC$SYMBOL2),
  fill_color = c("#440154", "#21908C", "#FDE725"),
  show_percentage = FALSE, text_size = 5) + ggtitle("MCF-7 enrichment") + theme(
  plot.title.position = "plot",
  plot.title = element_text(hjust = 0.5))
```

We next print a list of proteins in the four intersecting areas for further investigation in our disease of interest.

```{r GDA-list, results = "asis"}
# Print the list of proteins in each intersection
cat(paste("**Disease/Phospho:** ", paste(intersect(GDA_ERBC$gene_symbol, phospho_FC$SYMBOL2), collapse = ", ")))
cat(paste("**Disease/Total:** ", paste(intersect(GDA_ERBC$gene_symbol, total_FC$SYMBOL2), collapse = ", ")))
cat(paste("**Total/Phospho:** ", paste(intersect(total_FC$SYMBOL2, phospho_FC$SYMBOL2), collapse = ", ")))
cat(paste("**Disease/Phospho/Total:** ", paste(intersect(intersect(GDA_ERBC$gene_symbol, phospho_FC$SYMBOL2), total_FC$SYMBOL2), collapse = ", ")))
```

```{r clear-4}
# Clearing large variables
rm(GDA_ERBC, GDA_HT, GDA_OvCa, GDA_table_BC)
```


# 5. Epigenetic network
This section develops a network visualization of all epigenetic interactions as defined by EpiFactors (https://epifactors.autosome.org/). Increased dataset size may make networks difficult to visualize, so an interactive network is drawn in Python and rendered as an embedded HTML file.

The `data(genes)` call imports a .csv file included with the MPOInt package, but can be replaced to update or change the database by downloading and importing the "Table of all proteins" file on the EpiFactors website.

```{r network-setup}
data(genes)
total_join <- inner_join(genes, dplyr::select(MCF7_total_sig, "log2(FC)", "P value", "SYMBOL2"), by = join_by("HGNC approved symbol" == "SYMBOL2"), multiple = "any") %>% 
  mutate("Source" = "Total")

phospho_join <- inner_join(genes, dplyr::select(MCF7_phospho_sig, "log2(FC)", "P value", "SYMBOL2"), by = join_by("HGNC approved symbol" == "SYMBOL2"), multiple = "any") %>% 
  mutate("Source" = "Phospho")

joined_data <- full_join(total_join, phospho_join)

# Assigning differential expression identifiers
joined_data$Diff <- case_when(joined_data$`log2(FC)` > 0 ~ "Up",
                             joined_data$`log2(FC)` < 0 ~ "Down")
```

```{r network-proteins}
# Plotting all relevant proteins from the two combined datasets
ggplot(joined_data, aes(x = `log2(FC)`, y = -log10(`P value`))) +
  geom_point(aes(color = Source)) +
  geom_vline(xintercept = c(total_FC_threshold, -total_FC_threshold),
             alpha = 0.5, linetype = "dashed") +
  geom_hline(yintercept = -log10(total_p_threshold),
             alpha = 0.5, linetype = "dashed") +
  labs(x = "log2(Fold Change)", y = "-log10(P value)",
       title = "Combined data") +
  geom_text_repel(aes(label = `HGNC approved symbol`), show.legend = FALSE,
                  size = rel(3), max.overlaps = 20) +
  theme(legend.position = "bottom")
```
```{r network-histone-import}
# Formatting histone targets
targets <- str_replace_all(str_flatten_comma(str_unique(c(joined_data$Product, joined_data$`Target entity`))), ", ", "|")

# Filter by that list
total_histone_int <- filter(histone_single_p, grepl(targets, PTM))
total_histone_int$Diff <- case_when(total_histone_int$`log2(FC)` > 0 ~ "Up",
                             total_histone_int$`log2(FC)` < 0 ~ "Down",
                             .default = "0")
total_histone_int <- filter(total_histone_int, !grepl("unmod", PTM))

# Making sure that no histone data has gotten lost in processing - 
# this should match the figure from the earlier section
ggplot(total_histone_int, aes(x = `log2(FC)`, y = -log10(`P value`))) +
  geom_point() +
  geom_vline(xintercept = c(total_FC_threshold, -total_FC_threshold),
             alpha = 0.5, linetype = "dashed") +
  geom_hline(yintercept = -log10(total_p_threshold),
             alpha = 0.5, linetype = "dashed") +
  labs(x = "log2(Fold Change)", y = "-log10(P value)",
       title = "Included histone PTMs") +
  geom_text_repel(aes(label = PTM), show.legend = FALSE, size = rel(3)) +
  theme(legend.position = "bottom")
```

```{r network-genes}
# Pivoting and formatting the gene list
genes_pivoted <- dplyr::select(genes, c("HGNC approved symbol", "Protein complex", "Target entity", "Product")) %>% dplyr::rename("Symbol" = "HGNC approved symbol", "Complex" = "Protein complex", "Target" = "Target entity", "Product" = "Product")

genes_pivoted <- genes_pivoted %>% 
  separate_wider_delim(cols = c("Complex", "Target", "Product"), delim = ", ",
                       names_sep = "_", too_few = "align_start")

genes_pivoted <- genes_pivoted %>% 
  pivot_longer(cols = dplyr::starts_with("Complex"), names_to = NULL,
               values_to = "Complex", values_drop_na = TRUE) %>% 
  pivot_longer(cols = dplyr::starts_with("Target"), names_to = NULL,
               values_to = "Target", values_drop_na = TRUE) %>% 
  pivot_longer(cols = dplyr::starts_with("Product"), names_to = NULL,
               values_to = "Product", values_drop_na = TRUE)


genes_data_joined <- inner_join(genes_pivoted,
                                dplyr::select(joined_data, c("HGNC approved symbol",
                                                      "log2(FC)", "P value", "Source")),
                                by = join_by("Symbol" == "HGNC approved symbol"),
                                relationship = "many-to-many")
```

```{r network-format}
# Getting the lists into the right format for the igraph visualization
genes_histone_pivoted <- pivot_longer(genes_data_joined, cols = c("Target", "Product"), names_to = NULL,
             values_to = "PTM") %>% distinct()
genes_histone_pivoted$Diff <- case_when(genes_histone_pivoted$`log2(FC)` > 0 ~ "Up",
                             genes_histone_pivoted$`log2(FC)` < 0 ~ "Down",
                             .default = "0")

genes_histone_joined <- right_join(genes_histone_pivoted,
                                dplyr::select(total_histone_int, c("PTM",
                                                      "log2(FC)", "P value", "Diff")),
                                by = c("PTM" = "PTM"), suffix = c("_gene", "_hist"),
                                relationship = "many-to-many"
                                )
genes_histone_joined <- relocate(genes_histone_joined, Complex, .after = PTM)

# Ensuring no NA values remain, replacing "#" with a clearer identifier
genes_histone_joined[genes_histone_joined == "#"] <- "No ID"
genes_histone_joined$Complex <- genes_histone_joined$Complex %>%  replace_na("No ID")
```


```{r vertices-edges}
# Generating a dataframe for edges and a dataframe for unique vertices with metadata
complexes <- unique(genes_histone_joined$Complex)
n_complexes <- seq(1, length(complexes))
complex_df <- data.frame(complexes, n_complexes)

# Ensuring all histone PTMs have the same complex and source labels
histone_df <- dplyr::select(total_histone_int, c("PTM", "Diff"))
histone_df$Symbol <- histone_df$PTM
histone_df$Complex <- "No ID"
histone_df$Source <- "Histone"

vertices_df <- bind_rows(histone_df, dplyr::select(genes_histone_pivoted, !c("log2(FC)", "P value"))) %>% relocate("Symbol")
vertices_df <- filter(vertices_df, grepl("^H", PTM))
vertices_df$Complex <- case_when(vertices_df$Complex == "#" ~ "No ID",
                            .default = vertices_df$Complex)

# Creating a dataframe connecting edges (source and target vertices)
complex_vertices <- data.frame(vertices = c(unique(genes_histone_joined$Symbol), unique(genes_histone_joined$PTM)))
edges_df <- full_join(genes_histone_joined, complex_df, by = join_by("Complex" == "complexes")) %>% relocate(c("Symbol", "PTM"))
edges_df <- left_join(complex_vertices, edges_df, by = join_by("vertices" == "Symbol")) %>% rename("vertices" = "Symbol")

edges_df$Symbol <- case_when(is.na(edges_df$Symbol) ~ edges_df$PTM,
                               .default = edges_df$Symbol)
edges_df$PTM <- case_when(is.na(edges_df$PTM) ~ edges_df$Symbol,
                               .default = edges_df$PTM)
edges_df$Source <- case_when(is.na(edges_df$Source) ~ "Histone",
                               .default = edges_df$Source)
edges_df$Complex <- case_when(is.na(edges_df$Complex) ~ "No ID",
                               .default = edges_df$Complex)
edges_df$Diff <- case_when(edges_df$Source == "Histone" ~ edges_df$Diff_hist,
                             .default = edges_df$Diff_gene)
edges_df <- drop_na(edges_df, Diff)
```

This alternative visualization shows the members of the identified complexes without connections.

```{r network-bars}
sig_network <- distinct(group_by(filter(edges_df, Complex != "No ID"), Complex), Symbol, .keep_all = TRUE)
sig_network["weight"] <- 1
sig_network$Complex <- factor(sig_network$Complex, levels = unique(as.character(sig_network$Complex)))

PTM_colors <- setNames(c(paletteer_d("ggsci::default_igv", n = length(unique(histone_df$PTM)))), unique(histone_df$PTM))

#paletteer_d("ggsci::default_igv") 

#PTM_colors <- setNames(qualitative_hcl("Dark 3", rev = TRUE, n = length(unique(histone_df$PTM))), unique(histone_df$PTM))

ggplot(sig_network, aes(x = Complex, y = Symbol, fill = PTM)) +
  geom_bin_2d() +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust = 1),
        axis.title.x = element_blank(), axis.title.y = element_blank()) +
  scale_fill_manual(values = PTM_colors) +
  scale_y_discrete(limits = rev) +
  labs(title = "Figure 7d: Network bins")
```

## 5.1 Complex and member identification
For future research use, we generate multiple tables containing the identified complexes, members, common targets, and identified PTMs.

```{r complex-list, results = "asis"}
# Identified complexes
final_complexes <- filter(vertices_df, vertices_df$Source != "Histone") %>% filter(Complex != "No ID") %>% drop_na() %>% distinct()
final_complex_list <- unique(final_complexes$Complex)

cat(paste("**Networked Complexes:** ", paste(final_complex_list, collapse = ", ")))
```

```{r complex-members}
# List members of each
final_members <- data.frame("Complex" = "", "Members" = "", "PTMs" = "")

for (complex in final_complex_list) {
  member_df <- filter(final_complexes, final_complexes$Complex == complex)
  member_list <- paste0(unique(member_df$Symbol), collapse = ", ")
  member_PTMs <- paste0(unique(member_df$PTM), collapse = ", ")
  final_members <- final_members %>% add_row("Complex" = complex, "Members" = member_list, "PTMs" = member_PTMs)
}

knitr::kable(final_members)
```

```{r complex-PTMs}
# Differential PTMs
final_PTMs <- distinct(final_complexes, pick(PTM, Diff)) %>% rename("Diff" = "Differential expression")
knitr::kable(final_PTMs)
```


```{r complex-genes}
# Genes
final_proteins <- unique(final_complexes$Symbol)
final_func <- filter(genes, genes$`HGNC approved symbol` %in% final_proteins) %>% dplyr::select(!c("UniProt ID (human)"))
knitr::kable(final_func)
```

## 5.2 Python visualization
Finally, we create an interactive network using Python via the `reticulate` package. This allows a dynamic visualization that can be refined and filtered to generate different views.

```{r py-import}
vertices_df$Shapes <- case_when(vertices_df$Diff == "Up" ~ "triangle",
                             vertices_df$Diff == "Down" ~ "triangleDown",
                          vertices_df$Diff == "0" ~ "ellipse")

vertices_df$Colors <- PTM_colors[match(vertices_df$PTM, names(PTM_colors))]

vertices_df$Colors <- case_when(
  vertices_df$Source == "Histone" & is.na(vertices_df$Colors) ~ "gray",
  vertices_df$Source == "Histone" & !is.na(vertices_df$Colors) ~ vertices_df$Colors,
  vertices_df$Source == "Total" ~ "red",
  vertices_df$Source == "Phospho" ~ "blue")

sig_network_py <- filter(vertices_df, Complex != "No ID" | Source == "Histone") %>% r_to_py()

edges_py <- filter(edges_df, Complex != "No ID" | Source == "Histone") %>% r_to_py()
```

```{python py-setup}
import pandas as pd, networkx as nx
from pyvis.network import Network
```

```{python py-network}
# Create NetworkX graph object
G = nx.Graph()

# Generate a nested dictionary/tuple with the node of interest ("Symbol") and 
# the relevant attributes (shape and complex)
node_list = []
for i, row in r.sig_network_py.iterrows():
  node_list.append((row["Symbol"], {"color": row.Colors, "Complex": row.Complex, "shape": row.Shapes}))
G.add_nodes_from(node_list)

# Generate a tuple for edges connecting proteins with PTMs
edge_tup = []
for i in range(len(r.edges_py["Symbol"])):
  edge_tup.append((r.edges_py["Symbol"][i], r.edges_py["PTM"][i]))
G.add_edges_from(edge_tup)

# Remove self-loops
G.remove_edges_from(nx.selfloop_edges(G))

# Now remove nodes without edges
lone_nodes = [node for node, degree in G.degree() if degree == 0]
G.remove_nodes_from(lone_nodes)
```

```{python py-network-graph}
# To change the parameters of what's being graphed, adjust the initial call to Network()
net = Network(height="900px", notebook = True, select_menu = True, cdn_resources = "in_line")
net.from_nx(G)
net.save_graph("networkx-pyvis-MCF.html")
```

```{r print-HTML}
htmltools::renderDocument(htmltools::htmlTemplate("networkx-pyvis-MCF.html"))
```
